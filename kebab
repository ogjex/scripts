#!/usr/bin/env bash

# first let us outline all of the different functions necessary for the program to run
usage() {
	echo -e 'Usage: kebab [OPTIONS] [FILES or DIRECTORY]...\n\n'
        echo -e 'Arguments:\n   [FILES or DIRECTORY]... The files to rename or the directory to search through (eg. '*.filetype', '*', or '~/some-directory')\n'
        echo -e 'Options:'
        echo -e '   -h\n      Get this help output'
        echo -e '   -r\n      Recursively search through current directory depth first'
        
}
# check_files()
set_rename_pattern(){
    # Still an issue with unable to find and substitute first character of the string (in this case either - or _). Using the caret ^ does not seem to work
    pattern=$'s/_+|\s+/-/g; s/--+/-/g; s/-\./\./; y/A-Z/a-z/; y/ÆØÅ/æøå/'
    # reg ex pattern explained:
    # s/_+|\s+/-/g = find one or more underscores _ OR (|) one or more whitespace (\s) and replace with a dash -
    # s/--+/-/g = replace any dash trailed by one or more dashes (-+) with a single dash
    # s/-\./\./ = find the first encounter of -. and replace with a single dot (\.) to ensure that the file suffix is not overwritten.
    # y/A-Z/a-z/ = replace all lower case to upper case
    # y/ÆØÅ/æøå/ = replace all lower case DK chars to upper case (needs to be part of separate pattern for some reason.
}
rename_file(){
    # we first need to check all arguments to make sure that the selected files are valid
    if [[ $# -eq 0 ]]; then
        echo "Illegal number of parameters: $#" >&2
        usage
        exit 2
    else 
        arg_arr=("$@")

        ## now loop through the above array
        for i in "${arg_arr[@]}"
            do
                if [[ ! -e $i ]]; then
                   echo -e "$i is not a valid path.\nExiting." >&2
                   exit 2
                fi
            done
    fi
    # perform the rename on all elements in arg_arr
    set_rename_pattern
    
    count_var=$(perl-rename -fnv "$pattern" "${arg_arr[@]}" | wc -l)
    echo "The following $count_var elements will be renamed: "
    # the following needs to also be added 
    perl-rename -fnv "$pattern" "${arg_arr[@]}"

    read -p "Do you want to proceed with the rename? (y/n) " -n 1 -r
    echo -e "\n"

    if [[ $REPLY =~ ^[Yy]$ ]]
        then
            perl-rename -i "$pattern" "${arg_arr[@]}"
            # we need to find a way to count the number of times that the user has answered yes and use this as a variable

        else
            echo "Aborting."
    fi
    }

rename_recursively(){
    # check that only one argument is provided
    if [[ $# -ne 1 ]]; then
        echo "Illegal number of parameters: $#" >&2
        usage
        exit 2
    fi
    arg=$1
    if [[ ! -d $arg ]]; then
        echo "$arg is not a valid path."
        echo "Exiting..." >&2
        exit_fail
    else
       set_rename_pattern
       find $arg -depth -execdir perl-rename -fnv "$pattern" {} +
       read -p "Do you want to proceed with the rename? (y/n) " -n 1 -r
       echo    # (optional) move to a new line

       if [[ $REPLY =~ ^[Yy]$ ]]
       then
           # NEEDS TO BE FIXED ACCORDING TO: https://unix.stackexchange.com/questions/141086/how-can-i-use-rename-to-recursively-rename-everyting-to-uppercase
           # A simple way to avoid this difficulty is to make the renaming command act only on the base name part of the path. The regular expression ([^/]*\Z) matches the final part of the path that doesn't contain a / :
           # find . -depth -exec rename 's!([^/]*\Z)!uc($1)!e' {} +
           find $arg -depth -execdir perl-rename -fv "$pattern" {} +
           echo
           echo "Files renamed to kebab-case."
       fi
    fi
}

# function to call so save 
exit_fail() {
    usage
    exit 2
}

while getopts 'hr' opt; do
    # we need to remove the first argument in the args array (the option) to send the remaining array to the next functions
    shift $((OPTIND - 1))
	case "$opt" in
		h) usage; exit 0;;
		r) rename_recursively "$@"; exit 0;;
	 	*) usage >&2; exit 1;;
	esac
done

# with no options we can call the normal rename function taking the args array as arguments
rename_file "$@"
